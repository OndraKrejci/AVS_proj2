Architektury Výpočetních Systémů (AVS 2021)
Projekt č. 2 (PMC)
Login: xkrejc69

Úloha 1: Paralelizace původního řešení
===============================================================================

1) Kterou ze smyček (viz zadání) je vhodnější paralelizovat a co způsobuje 
   neefektivitu paralelizaci té druhé?
- je výrazně efektivnější paralelizovat první smyčku (například pro schedule(static) je paralelizace první 14x rychlejší)
- první smyčka je na vyšší úrovni a obsahuje v sobě druhou, dojde tak k paralelizaci většího množství kódu
- vzhledem k tomu, že druhá smyčka je vnořená tak je dále možné, že režie na opakované vytváření paralelních oblastí způsobí vyšší zpomalení,
  tomu také napovídá, že smyčka je pro schedule(guided) ještě výrazněji pomalejší než pro static/guided,
  tzn. iterace smyčky se provádí příliš rychle a režie pro plánování dynamic zabere více času, než je získáno paralelizací

2) Jaké plánování (rozdělení práce mezi vlákna) jste zvolili a proč? 
   Jaký vliv má velikost "chunk" při dynamickém plánování (8, 16, 32, 64)?
- při testování rychlosti pro různé plánování s různými chunk size  se mezi sebou typy plánování pro větší vstupy (bun_zipper_res1.pts, grid_size=64|128)
  lišily minimálně
- pro menší vstupy (bun_zipper_res4.pts) a grid_size=32|64 opět nebyl mezi typy plánování výrazný rozdíl a jelikož se jednalo o rozdíly v řádech stovek ms,
  tak jsou tyto rozdíly stejně zanedbatelné
- velikost chunk pro dynamické plánování opět nemá žádný vliv na rychlost, pro libovolně velký vstup (bun_zipper_res4.pts, bun_zipper_res1.pts,
  dragon_vrip_res1.pts) je rychlost pro všechny velikosti chunk 1-64 stejná
- vzhledem k tomu, že rychlost není významně ovlivněna způsobem plánování, tak jsem použil nejjednodušší statické plánování

3) Jakým způsobem zajišťujete ukládání trojúhelníků z několika vláken současně?
- vzájemným vyloučením pomocí #pragma omp critical


Úloha 2: Paralelní průchod stromem
===============================================================================

1) Stručně popište použití OpenMP tasků ve vašem řešení.

2) Jakým způsobem jste realizovali sesbírání celkového počtu trojúhelníků?

3) Jaký vliv má na vaše řešení tzv. "cut-off"? Je vhodné vytvářet nový 
   task pro každou krychli na nejnižší úrovni?

4) Jakým způsobem zajišťujete ukládání trojúhelníků z několika vláken současně?

Úloha 3: Grafy škálování všech řešení
===============================================================================

1) Stručně zhodnoťte efektivitu vytvořených řešení (na základě grafů škálování).

2) V jakém případě (v závislosti na počtu bodů ve vstupním souboru a velikosti 
   mřížky) bude vaše řešení 1. úlohy neefektivní? (pokud takový případ existuje)

3) Je (nebo není) stromový algoritmus efektivnější z pohledu slabého škálování 
   vzhledem ke vstupu?

Úloha 4: Analýza využití jader pomocí VTune
================================================================================

1) Jaké bylo průměrné využití jader pro všechny tři implementace s omezením na 
   18 vláken? Na kolik procent byly využity?
   
   ref:
   loop:
   tree:

2) Jaké bylo průměrné využití jader pro všechny tři implementace s využitím 
   všech jader? Na kolik procent se podařilo využít obě CPU?
   
   ref:
   loop:
   tree:

3) Jaké jsou závěry z těchto měření?

